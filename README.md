Лекция, 13.03.2024
## Стек
### Функциональная спецификация
Функциональные спецификации очереди и стека почти не отличимы на математическом уровне. Разве что можно сказать, что стек это горизонтальная структура, а очередь - вертикальная.

### Логическое описание
Стек, как и очередь, является рекурсивной структурой данных и может быть описан рекурсивно как конкатенация элемента типа *T* и некоторого стека *s* типа $S_T$.
#### Язык программирования со стековой моделью вычислений
В языке Форт нет массивов, в нём есть только стек, поэтому он очень хорош в задачах, основанных на стеке. Стек оказывается чрезвычайно удобным для вычисления и представления арифметических выражений. Например, обратная польская запись помогает избавиться от скобок и соглашений о приоритете операций (в ней используется постфиксная запись).
также стек идеально подходит для передачи параметров функциям и процедурам. В языке Форт функции берут нужное количество аргументов со стека, вычисляют результат и возвращает на стек.
Огромное преимущество такой машины в том, что ей не нужно адресовать результат в память, все действия происходят на верхушке стека. Такие машины быстры и имеют более короткие команды (программы становятся компактнее).
На экзамене будет задача о обратной польской записи.
#### Реализация на массиве
Аналогично очереди, ограничим размер (глубину) стека величиной $POOL\_SIZE$
Все элементы стека в таком случае размещаются в массиве $data$ длины $POOL\_SIZE$. Переменная $size$ играет важную роль в стеке: она определяет глубину стека, причём $size-1$ является индексом вершины стека.
```C
typedef struct {
	int size;
	T data[POOL_SIZE];
} stack;

void Create(stack* s) {
	s->size = 0;
}

bool Empty(stack* s) {
	return s->size == 0;
}

int Size(stack* s) {
	return s->size;
}

bool Push(stack* s, T t) {
	if (s->size >= POOL_SIZE) {
		return false;
	}
	s->data[s->size++] = t;
	return true;
}

bool Pop(stack* s) {
	if (s->size == 0) {
		return false;
	}
	s->size--;
	return true;
}

T Top(stack* s) {
	if (s->size) {
		return s->data[s->size - 1];
	}
	abort();
}

void Destroy(stack* s) {
	s->size = 0;
}
```
Упражнение (плюс на экзамене): сделайте стек на векторе.
Стек на файле хуже очереди не файлах, потому что очередь это долговременная структура, а стек - резидентная, долговременный стек никогда не нужен и даже звучит странно. Стек должен быть быстрым, что не позволит реализация на файлах.
#### Реализация на динамических структурах
Опишем реализацию стека на динамических структурах. Для этого понадобится тип "элемент стека", который содержит значение и ссылку на следующую компоненту.
```C
struct Item {
	T data;
	struct Item* prev;
};

typedef struct {
	struct Item* top;
	int size;
} stack;

void Create(stack* s) {
	s->top = 0;
	s->size = 0;
}

bool Empty(stack* s) {
	// а не s->size == 0
	return  s->top == 0;
}

int Size(stack* s) {
	return s->size;
}

// На экзамене приводи рисунок, схематично изобрази указатели и компоненты
bool Push(stack* s, T t) {
	struct Item* n = malloc(sizeof(struct Item));
	if (!n) {
		return false;
	}
	n->data = t;
	n->prev = s->top;
	s->top = n;
	++s->size;
	return true;
}

// На экзамене приводи рисунок, схематично изобрази указатели и компоненты
bool Pop(stack* s) {
	if (Empty(s)) {
		return false;
	}
	struct Item* i = s->top;
	s->top = s->top->prev;
	--s->size;
	free(i);
	return true;
}

T Top(stack* s) {
	if (!Empty(s)) {
		return s->top->data;
	}
	abort();
}

// Мы не пользуемся уже готовой функцией Pop, потому что тогда низкоуровневая функция Destroy станет высокоуровневой, так как будет опираться на другие низкоуровненые функции.
void Destroy(stack* s) {
	while (s->top) {
		struct Item* i = s->top;
		s->top = s->top->prev;
		free(i);
	}
	s->top = 0;
	s->size = 0;
}
```

>"Почему милиционеры ходят по двое? Один умеет читать, другой - писать"
> (с) В. Е. Зайцев

Очередь - двухголовочная структура, а стек - одноголовочная.

Встречные стеки (Предложил профессор Жоголев).
Случай, когда два стека располагаются навстречу друг другу в одном массиве, что позволяет двум стекам поочередно пользоваться общим свободным пространством, сохраняя простоту и быстроту отображения реализации стека на массиве.

```
item_1
item_2
...
item_n
  \/


  /\
item_k
...
item_2
item_1
```

## Линейный список
Линейный список является обобщением последовательных структур с ограниченным доступом. Они позволяют представить последовательность элементов, но место для чтения и записи не фиксировано, каждый элемент доступен и для этого не нужно извлекать из структуры предшествующие элементы. Чтение списка **не разрушающее**. 
Линейный список - это представление в ЭВМ конечного упорядоченного (упорядоченное по хронологии, а не по значению) динамического множества элементов типа $T$. Вернее сказать, что это мультимножество, то есть такое множество, в котором элементы могут повторяться. 
Примером списка может послужить пять пронумерованных элементов (причём номера это не адреса).
Списки нужны тогда, когда нужны упорядоченные множества переменного размера, где включение, поиск и удаление элементов должны выполняться в произвольных последовательно достигаемых местах, но с сохранением порядка следования.
Наиболее простой пример списка в информатике: список переменных в описаниях типов переменных.

Поиск элемента в списке происходит за линейное время, причём структура списка не должна изменяться.
Для некоторых нелинейных структур (например, разреженных матриц, представляемых в виде списка списков элементов) время поиска элемента пропорционально $N^2$.

Рассмотрим добавление элемента в линейных список. Интересно, что добавление происходит по значению, а не по адресу. Итак, надо сначала найти элемент с нужным значением, а затем вставить элемент (а если не нашли, значит и вставлять нельзя? Ну, можно вставлять в конец в списка). Вставка может быть спереди или после значения. Для двусвязного списка легко сделать вставку "перед", а для односвязного легче "после". Обычно подразумевается вставка "после", но для вставки в отсортированную последовательность больше подойдёт "перед". 

Удаление обычно связанно с поиском, следовательно, работает за линейное время.

Можно заметить, что все операции в списке происходят за линейное время, причём это время постоянное. Хотя стек, очередь и дек имеют вставку и удаление за константу, линейное время за произвольный доступ - справедливая плата.

### Функциональная спецификация
Полная спецификация двусвязного линейного списка $L_T$ объектов типа $T$ достаточно длинна:
$СОЗДАТЬ:\ \ \emptyset \to L_T$
$ПУСТО:\ \ \ L_T\to\textbf{boolean}$
$ДЛИНА:\ \ \ L_T\to\mathbb{N}\cup\{0\}$
$ПЕРВЫЙ: L_T\to T$
$ПОСЛЕДНИЙ: L_T\to T$
$СЛЕДУЮЩИЙ: L_T \times T\to T$
$ПРЕДЫДУЩИЙ: L_T \times T\to T$
$ВСТАВКА: L_T \times T\times T\to L_T$
$УДАЛЕНИЕ: L_T\times T\to L_T$
$УНИЧТОЖИТЬ: L_T\to \emptyset$

Свойства списка:
1. $ПУСТО(СОЗДАТЬ) = \textbf{true}$
2. $ПУСТО(ВСТАВКА(l, t, t)) = \textbf{false}$
3. $ПРЕДЫДУЩИЙ(СЛЕДУЮЩИЙ(t))=t$
4. $СЛЕДУЮЩИЙ(ПРЕДЫДУЩИЙ(t)) = t$
5. $l := СОЗДАТЬ$
	$l := ВСТАВКА(l, t_2, t_2)$
	$l := ВСТАВКА(l, t_2, t_1)$
	$ПЕРВЫЙ(l)=t_1$
	$ПОСЛЕДНИЙ(l)=t_2$

 >"Будьте здоровы! ... Проветривают сегодня ... А это не нас проветривают, а теремок, весь день жаренным пахнет. Скоро закоптимся тут. Холодное копчение gjkexftncz: холодно, и запах стоит. Студенты холодного копчения!"
 >(c) В. Е. Зайцев

### Логическое описание
Списки являются стандартными структурами данных в Лиспе и Прологе. Более того, в Лиспе это основная структура.
В Прологе реализация списка рекурсивная: пустой список является список, он обозначается символом $[]$. Функтор . (точка) образует новый список путём добавления нового элемента в начало исходного списка.

Дальше мне было лень писать
### Физическое представление
Снова лень
#### Итераторы
Для реализации сложных динамических структур данных цепного или сплошного характера принято использовать так называемые итераторы.
Введём объекты, обладающие функциями перехода от элемента списка к соседним. Зададим для них отношения равенства и неравенства: они равны, если указывают на один элемент списка. Также предоставим возможность чтения и записи элемента на один и тот же элемент списка. Такие объекты принято называть *итераторами*. Похоже на указатели, не правда ли? Но итераторы выполняют работу над последовательностями более благородно, абстрактно, в отличие от низкоуровневых указателей. Также итераторы позволяют предотвращать разные ошибки, ограничивая наше всевластие.

Итак, итератор предназначен для навигации по списку, чтения и перезаписи элементов списка.

Как обычно, создадим элемент терминатор, значениями next и prev которого будут указывать на начало списка и на конец списка соответственно. Таким образом, сразу мы имеем доступ только к начальному и конечному элемент, к произвольному элементу происходит за линейное время. Если задача требует только краёв списка, то алгоритм будет работать не за линию. 
Заметим, что список довольно похож на файл. Причём не только последовательным доступом, но и неразрушающим чтением.

Начнём описывать структуру списка. Он хранит все два значения: указатель на терминатор и размер списка:

```c
typedef struct {
	Item* head;
	size_t size;
} List;
```

Создание списка требует правильной настройки терминатора и, конечно, выделения памяти:

```C
void Create(List* l) {
	l->head = malloc(sizeof(struct Item));
	l->head->next = l->head->prev = l->head;
	l->size = 0;
}
```

Итераторная функция First возвращает итератор на первый компонент списка:
```C
Iterator First(const List* l) {
	// Эта функция превращает указатель в итератор
	Iterator res = { l->head->next };
	return res;
}
```

> "Си вычислим по Тьюрингу в 5.5 раз больше, чем Паскаль"

Теперь сделаем функцию Last(), она будет возвращать итератор на терминатор:
```C
Iterator Last(const List* l) {
	Iterator res = { l->head };
	return res;
}
```

Список по построению, если его начало и конец совпадают:
```C
bool Empty(const List* l) {
	Iterator fst = First(l);
	Iterator lst = Last(l);
	return Equal(&fst, &lst);
}
```

Функция size просто возвращает размер:
```C
int Size(const List* l) {
	return l->size;
}
```

Самое интересное сделать функцию Insert, потому что нужно правильно перенастроить указатели:
```C
Iterator Insert(List* l, Iterator* i, const T t) {
	Iterator res = { malloc(sizeof(struct Item)) };
	if (!res.node) return Last(l);
	res.node->data = t;
	res.node->next = i->node;
	res.node->prev = i->node->prev;
	res.node->prev->next = res.node;
	i->node->prev = res.node;
	++(l->size);
	return res;
}
```

Похожая история происходит при удалении элемента:
```c
Iterator Delete(List* l, Iterator* i) {
	Iterator res = Last(l);
	if (Equal(i, &res)) return res;  // Терминальный элемент удалять нельзя
	res.node = i->node->next;  // Рассматриваем всё-таки i
	res.node->prev = i->node->prev;
	i->prev->next = res.node;
	--(l->size);
	free(i->node);
	i->node = 0;
	return res;
}
```

```C
void Destroy(List* l) {
	struct Item* i = l->head->next;
	while (i != l-> head) {
		struct Item* pi = i;
		i = i->next;
		free(pi);
	}
	free(l->head);
	l->head = 0;
	l->size = 0;
}
```

Такая реализация хороша, предполагает бесконечный размер списка, но достаточно неэффективна засчёт постоянного выделения и очищения памяти.

#### Реализация на массиве
Мы можем повторно воспользоваться концепцией итераторов. Во-первых, это действительно удобно. Во-вторых мы сэкономим много времени, избавляя себя от переписывания кода.

Сразу стоит отметить недостаток реализации на массиве: мы ограниченны размером $POOL\_SIZE$.
```C
const int POOL_SIZE = 100;

typedef struct {
	struct Item* head;
	int size;
	struct Item* top;
	// Размер на 1 больше: не забываем про терминатор
	struct Item data[POOL_SIZE + 1];
} List;
```

Изначально массив пуст и массив data считается свободным. В последнем элементе ($data[POOL\_SIZE]$) будет лежать терминатор. Для каждого элемента нужно хранить индексы на следующий и предыдущий элемент (next и prev).

> "Надо найти маркер, который менее голубой и более синий. Это количество маркеров обманчиво"

При создании нужно отформатировать массив под список так, чтобы каждый индекс указывал на следующий. Терминатор указывает сам на себя. Указатель на следующий элемент у последнего значащего элемента списка должен быть нулевым (никто не указывает).

```C
void Create(List* l) {
	int i;
	for (i = 0; i < POOL_SIZE; ++i) {
		l->data[i].next = l->data[i + 1].next;
	}
	l->data[POOL_SIZE - 1].next = 0;
	l->head = &(l->data[POOL_SIZE]);
	l->head->prev = l->head->next = l->head;
	l->top = $(l->data[0]);
	l->size = 0;
}
```

Благодаря такому подходу, можно почти полностью скопировать функцию Insert:
```C
Iterator Insert(List* l, Iterator* i, const T t) {
	Iterator res = { l->top };  // Тут отличие
	if (!res.node) return Last(l);
	l->top = l->top->next;  // Новая строчка
	
	res.node->data = t;
	res.node->next = i->node;
	res.node->prev = i->node->prev;
	res.node->prev->next = res.node;
	i->node->prev = res.node;
	++(l->size);
	return res;
}
```

Удаление элемента тоже почти не надо переписывать. Но теперь нам не нужно возвращать память операционной системе, однако нужно вернуть этот элемент самом массиву
```C
Iterator Delete(List* l, Iterator* i) {
	Iterator res = Last(l);
	if (Equal(i, &res)) return res;
	res.node = i->node->next;
	res.node->prev = i->node->prev;
	i->node->prev->next = res.node;
	--(i->size);

	i->node->next = l->top;
	l->top = i->node;

	i->node = 0;
	return res;
}
```

Заметим, что функция Destroy очень и очень проста:
```C
void Destroy(List* l) {
	l->head = 0;
	l->size = 0;
	l->top = 0;
}
```

Таким образом, мы получили новую реализацию, переписав только места работы с памятью. Это наталкивает на мысль, что функцию Create() можно параметризовать. В частности, в стандартной библиотеке C++ все контейнеры в качества аргумента по умолчанию принимаю стандартный распределитель памяти (allocator).

## Дек
Дек - двухсторонняя очередь, динамическая структура данных, в которой элементы можно добавлять и удалять как в начало, так и в конец.
Операции над деком:
- Включение элемента справа
- Включение элемента слева
- Исключение элемента справа
- Исключение элемента слева
- Определение размера
- Очистка

Физическая структура дека в статической памяти идентична структуре кольцевой очереди. Динамическая реализация является очевидным объединением стека и очереди.

На экзамене есть задача: как правильно удалить дек (он имел в виду рекурсию).

**Здесь мы закончили линейные структуры.**
## Деревья
Деревья наиболее приспособлены для решения задач искусственного интеллекта и синтаксического анализа. 

Деревья, так же как и списки, хранят элементы в каком-то порядке. Деревом над типом T называется структура, которая образованна корнем и конечным, возможно пустым, числом деревьев такого же типа, называемых поддеревьями этого дерева.d

Дерево - это нелинейная, самоподобная, "фрактальная" структура.
Способы изображения деревьев (рисунки см. начиная со стр. 282):
1. Структурно-топологическое изображение
2. Вложенные диаграммы включения Эйлера-Венна
3. Иерархические скобочные структуры
4. Многоуровневая ступенчатая запись

В дискретной математике распространены матрицы смежности и списки инцидентности. 
1. Элементы типа $T$, входяшие в дерево, называются узлами или вершинами.
2. Степень дерева - количество её поддеревьев (детей). 
3. Степень, не имеющий поддеревьев, называется концевым узлом, листом или терминальной вершиной (хотя терминальная может не быть листом).
4. Неконцевые узлы называются внутренними или узлами разветвления.
5. Уровень узла в дереве рекурсивно определяется так:
	1. Корень дерево имеет уровень 1.
	2. Корень каждого поддерева данного узла имеет уровень на единицу больше уровня этого узла.
6. Глубиной называется наибольшее значение уровня вершины. Заметим, что достаточно рассмотреть только листья.

Для описания взаимного расположения узлов принята терминология генеалогических деревьев, соответствующая родственным отношениям между лицами мужской линии (отце, сын или предок и потомок, хотя вершина - дочерняя).
Иногда требуется упорядочивать сыновей. В этом случае употребляются термины "старший", "младший", "средний". Причём удобно указывать их в виде очереди, причём от родителя идёт только одно ребро - к старшему сыну.

### Двоичные деревья
Ещё их называют бинарными. И оба этих названия неудачные.
Бинарное дерево - это конечное множество узлов, которое или *пусто* или состоит из корня и двух не пересекающихся поддеревьев, называемых левым и правым поддеревьями данного узла.
``` 
Это разные деревья:
    A      A
   /        \
  B          B
```
Помимо особенности с расположением потомка, бинарное дерево может быть пустым в отличие от деревьев общего вида.
Бинарные деревья проще хранить и обрабатывать.

Хорошим примером является дерево выражений.
Мультипликативные операции: умножение, деление и взятие остатка.
Аддитивные: сложение, вычитание.

Следующий пример: турнирное дерево.

### Двоичная интерпретация дерева общего вида
Это теоретический, отдельный вопрос на экзамене.
У каждого узла нужно соединить его сыновей, убрать все связи между сыновьями и этим узлом, оставив только одну связь.
![[Pasted image 20240327134148.png]]
Получаем нисходяший правосторонний каскад. Далее подвешиваем дерево за корень.
Итак, "ширина" дерева стала меньше - дерево стало бинарным, а глубина - значительно увеличилась.

Общий алгоритм. Пусть есть обычное дерево A и двоичное дерево B. Применяем следующие правила:
- Корень B есть корень А
- Левое поддерево двоичного дерева B есть результат этого же преобразования первого поддерева дерева A, если он существует.
- Правое поддерево двоичного дерева B есть результат этого преобразования очередного брата узла A, если он существует.
![[Pasted image 20240327135052.png]]

Упражнение: Нарисовать своё дерево и попробовать его преобразовать.
Замечания: 
- Пустое дерево получить нельзя.
- Данный алгоритм применим и в обратную сторону. Доказательство индукцией по глубине дерева. Для корня это верно. Предположим, что для дерева $k$ уровня это верно. Для $k+1$ сделаем левое поддерево сыном, а правое - его братом.

### Функциональная спецификация
Тип $BT_T$, или *двоичное дерево типа T*, определяется так:
1. СОЗДАТЬ:             $\emptyset\to BT_T$ 
2. ПОСТРОИТЬ:       $BT_T\times T\times BT_T \to BT_T$
3. ПУСТО:                  $BT_T\to boolean$
4. КОРЕНЬ:                $BT_T\to T$
5. СЛЕВА:                  $BT_T\to BT_T$
6. СПРАВА:                $BT_T\to BT_T$
7. УНИЧТОЖИТЬ:     $BT_T\to \emptyset$

Задача на экзамене: как моделировать очередь на двух ?деках?

Свойства операций:
1. ПУСТО(СОЗДАТЬ) = true
2. ПУСТО(ПОСТРОИТЬ($bt_l, t, bt_r$)) = false
3. КОРЕНЬ(ПОСТРОИТЬ($bt_l, t, bt_r$)) = t
4. СЛЕВА(ПОСТРОИТЬ($bt_l, t, bt_r$)) = $bt_l$
5. СПРАВА(ПОСТРОИТЬ($bt_l, t, bt_r$)) = $bt_r$
6. ПОСТРОИТЬ(СЛЕВА($bt$), КОРЕНЬ($bt$), СПРАВА($bt$)) = $bt$
7. 
![[Pasted image 20240327140419.png]]
Упражнение: Найти ещё несколько полезных операций
### Логическое описание

> "Паскаль + Си = Питон". (с) В. Е. Зайцев

К сожалению, нету готовых структур в стандартных библиотеках. Это связанно с тем, что деревья сильно разнообразны и нету универсальных способов работы с ним.

Цепная структура будет состоять из динамически порождаемых элементов, в которых предусмотрены ссылки на очередные компоненты структуры. Узел будет состоять из значения (буквы, номера), указателей на левого и правого потомка.
```C
struct node {
	char key;
	struct node* l;
	struct npde: r;
}
```
Указатель $root$ будет указывать на вершину, которая будет корнем дерева.
Операнды и константы всегда находятся в листьях. При вычислении выражения появляются промежуточные и ненастоящие операнды.

## Алгоритмы обработки деревьев
### Понятие обхода дерева
Обход - это просмотр/посещение **всех, без исключения, узлов дерева**,  причём **не более одного раза**,  вершины просматриваются в **определённом порядке**.
Алгоритмов обхода может быть несколько. В результате обхода все вершины будут рассмотрены. Если пройденные вершины заносить в очередь или список, то этот порядок станет некоторой линеаризацией дерева.

На экзамене, прежде чем рассказывать про алгоритмы обхода, нужно дать определение обхода
### Алгоритмы обхода двоичных деревьев
Существует три способа обхода бинарного дерева: прямой (сверху вних), обратные (слева направо) и концевой (снизу вверх)
1. При прямом обходе (КЛП, preorder, корень прежде):
	1. если дерево пусто, то конец обхода
	2. берётся корень
	3. выполняется обход левого поддерева
	4. выполняется обход правого поддерева
2. При обратно обходе (ЛКП, inorder, корень между):
	1. если дерево пусто, то конец обхода
	2. выполняется обход левого поддерева
	3. берётся корень
	4. выполняется обход правого поддерева
3. При концевом обходе (ЛПК, postorder, корень в конце):
	1. если дерево пусто, то конце обхода
	2. выполняется обход левого поддерева
	3. выполняется обход правого поддерева
	4. берётся корень

Замечание: при обходах желательно использовать слово "очередь", чтобы подчеркнуть определённый порядок.

При обходе можно использовать рекурсивные процедуры, либо программы с циклом (который, впрочем, будет моделировать состояние стека во время рекурсии)

Упражнение: напиши все эти алгоритмы.
```c
void preorder(Node* node) {
	if (node == NULL) {
		return;
	}
	printf("%s ", node->key);  // обработка вершины
	preorder(node->l);
	preorder(node->r);
}

void inorder(Node* node) {
	if (node == NULL) {
		return;
	}
	preorder(node->l);
	printf("%s ", node->key);  // обработка вершины
	preorder(node->r);
}

void postorder(Node* node) {
	if (node == NULL) {
		return;
	}
	preorder(node->l);
	preorder(node->r);
	printf("%s ", node->key);  // обработка вершины
}
```

Упражнение: напиши эти алгоритмы на циклах:
```c++
void preorder_iteration(Node* node) {
	std::stack<Node*> buffer;
	buffer.add(node);
	while (!buffer.empty()) {
		Node* cur = buffer.top();
		buffer.pop();
		if (cur == nullptr) continue;
		std::cout << cur->key << ' ';  // обработка вершины
		buffer.add(cur->left);
		buffer.add(cur->right);
	}
}
```

### Построение и визуализация дерева
Типичный пример программы, в которой нужно совершить обход дерева: рекурсивная процедура ступенчатой распечатки дерева.

Сначала нужно дерево построить.
**Упражнение**: по входным данным в виде последовательности букв, построить двоичное дерево минимальной глубины.

     1 2 3 4 5 6 7 8
inp = a  b  c d  e  f  g  h

Потомки вершины $a_i$ - $inp[i * 2]$ и $inp[i * 2 + 1]$  
```
                  a
                /   \
               b     c
              / \   / \
             d   e f   g
            /
           h
```

Упражнение: написать вывод дерева с отступами.
А рисование с отступами можно сделать так:
```c++
void print_tree(Node* node) {
	if (node != nullptr) {
		
	}
}
```


### Деревья выражений. Разнофиксные формы записи выражений
Выражения:
- арифметические
- логические
- информатические
 Выражения нелинейны и рекурсивны. Для машины Фон Неймана, которая имеет дело с массивами, это приносит большое неудобство.
 
 Мы уже видели дерево выражений. Деревом выражения называется дерево, узлами которого являются операции, а листья - операнды. Все дети одной операции являются её операндами.

Ввиду того, что в машине фон Неймана все операции бинарные, деревья будут бинарными.

Деревья, хотя это нелинейные структуры, не имеют недостатка в виде скобок и определения приоритета операций.

Существуют следующие виды записей выражений:
1. Префиксная. Это машинное представление: `+ a b`
2. Инфиксная. Это математическое представление: `a + b`
3. Постфиксная. `a b +`

Заметим большое сходство с обходами деревьев: обходя дерево выражений разными способами, мы будем получать эти виды записей!

##### Алгоритм Рутисхаузера
Один из наиболее ранних алгоритмов. Был придуман ещё до всех языков программирования.
Он предложил алгоритм работы с выражениями.

Берём выражение. В нём должно быть полная скобочная структура, то есть порядок выражений задаётся скобками. Выражение состоит из символов (не букв!).
Каждый символ снабжается уровнем. Если скобка открылась, то уровень этого выражения увеличиваются на 1. Операнд имеет уровень на 1 больше, чем текущий. Операция имеет такой же уровень. Если скобка закрылась, то уровень этого выражения уменьшается.

| № литеры          | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
| ----------------- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| Символы (лексемы) | (   | A   | +   | (   | B   | *   | C   | )   | )   |
| Номера уровней    | 1   | 2   | 1   | 2   | 3   | 2   | 3   | 2   | 1   |

Этапы алгоритма:
1. Расставить уровни
2. Отыскать элементы строки с максимальным значением уровня
3. Выделить тройку - два операнда с максимальным значением уровня и операцию, которая заключена между ними
4. Результат выполнения выделенной операции обозначить вспомогательной переменной
5. Из исходной строки удалить выделенную тройку вместе с её скобками, а на её место пометить вспомогательную переменную, обозначающую результат, со значением уровня на единицу меньшим, чем у выделенной тройки.
6. Выполнять п.п. 2-5 до тех пор, пока во входной строке не останется одна переменная, обозначающая общий результат выражения
![[Pasted image 20240327155453.png]]

Упражнение: реализовать этот алгоритм.
На экзамене будет задачка с этим алгоритмом.

##### Алгоритм Бауэра-Замельзона
Используются два стека и таблица функций перехода. Один стек (Т) используеся при трансляции выражения, а второй (У) - во время интерпретации выражения

1. Заслать операцию из входной строки в стек Т. Читать следующий символ строки
2. Выделить тройку - взять операцию с вершины стека Т и два операнда с вершины стека Е. Вспомогательную переменную - результат операции - занести в стек Е. Заслать операцию их входной строки в стек Т. Читать следующую лексему строки
3. Исключить лексему из стека Т. Читать следующий символ строки
4. Выделить тройку - взять операцию с вершины стека Т и два операнда с вершины стека Е. Вспомогательную переменную - результат операции - заанести в стек Е. По таблице определить функцию для данной лексемы входной строки.
5. выдача сообщения об ошибке
6. завершение работы

Упражнение: написать алгоритм Буэра-Замельзона!
![[Pasted image 20240327161517.png]]
![[Pasted image 20240327161525.png]]

##### Алгоритм сортировочной станции Дейкстры -
способ разбора математических выражений, представленных в обычной инфиксной нотации.

Это единственный алгоритм, который мы изучаем подробно. 
Выражение представлено в обычной инфиксной записи.
Для разбора выражения применяется алгоритм Дейкстры, который напоминает железнодорожную станцию.

Алгоритм работает при помощи стека. Если нужна обратная польская запись, то нужно создать две очереди: очередь лексем и выходная очередь (содержащая выражение в обратной польской записи). Стек будет хранить то, что ещё не было добавлено в очередь. На потом будем откладывать менее обратные операции.

Порядок операндов не меняется!!!

Считать лексему.

Если это операнд, добавить в итоговую очередь.
Если это функция, то поместить в стек.
Если у функции есть аргументы перекладывать операции из стека в выходную очередь. Если в выражении не было открывающей скобки или пропущен разделитель, то вызвать ошибку.

### Обход дерева общего вида
Деревья имеют более сложную структуру, чем двоичные, поэтому их обход тоже становится немного сложнее. КЛП обход является обходом в глубину на двоичном дереве. Для обхода в ширину двоичного аналога нет.

Итак, если сначала перебираются братья, то мы получим обходим в ширину.
Если сначала перебираются сыновья, то мы получим обход в глубину.

На экзамене обязательно привести определение обхода.

1. При поиске в глубину:
	1. если дерево пусто, то конец обхода
	2. берётся корень
	3. выполняется поиск в глубину для поддерева старшего сына
	4. выполняется поиск в глубину для следующего брата
2. При поиске в ширину:
	1. поместить в пустую очередь корень
	2. если очередь узлов пуста, то конец обхода
	3. извлечь первый элемент из очереди узлов и поместить в её конец всех его сыновей по старшинству
	4. повторить п. 2.2.

### Физическое представление. Отображение на массив
Если у дерева фиксированная структура, то можно пользоваться сплошным представлением дерева.
Возьмём двоичное дерево, в котором все пары заполнены.
Тогда первый элемент - корень, следующие два - его дети. Для элемента с индексом $i$ его детьми будут элементы массива с индексами $2i$ и $2i + 1$.
Этот метод экономичен по памяти.
Неудобен этот метод тем, что вставка достаточно дороги.

#### Прошивка деревьев
В хорошем бинарном дереве количество листьев занимает около половины узлов дерева. То есть мы тратим огромное количество памяти, чтобы хранить $nullptr$.
Давайте использовать эти пустые ссылки для линеаризации.

Тут я ничего не понял. Придётся гуглить.

## Деревья поиска
Если дерево организовано так, что для каждой вершины $t_i$ справедливо утверждение, что все ключи левого поддерева $t_i$ меньше ключа $t_i$, а все ключи правого поддерева $t_i$ больше его, то такое дерево называется *деревом поиска*.
При поиске нам достаточно рассматривать только значение текущего ключа, причём при переходе мы отбрасываем половину дерева. Таким образом, поиск в таком дереве работает за логарифмическую сложность $O(log N)$

```C
p* locate(int x, p* t) {
	while (t != NULL && t->key != x) {
		if (t->key < x) t = t->r;
		else t = t->l;
	}
	return t;
}
```

На экзамене надо сказать про идею с барьерным элементом, так нужно упомянуть, что в других структурах этот элемент уже помогал. Нужно сказать про достоинства и недостатки.
### Поиск по дереву с включениями
Дерево поиска - некая нелинейная таблица. Под таблицей здесь понимается некая структура вида "ключ - значение".
Добавление элемента в дерево - уже нетривиальная задача.
Рассмотрим задачу составления частотного словаря.
Пусть элемент дерева поиска имеет следующее рекурсивное описание:
```c
struct word {
	int key;
	int count;
	word* l;
	word* r;
}
```

Программа поиска по дереву с включениями очень проста:
```c
while (scanf("%d", &key) == 1) {
	search(key, &root);
}
```

Когда мы пытаемся найти элемент, которого нет в дереве, алгоритм `locate` встанет на одном из листьев, там, где этот элемент должен быть.

```c
typedef struct word* wp;

int main() {
	int n;
	int key;
	wp root = NULL;

	while (scanf("%d", &key) == 1) {
		search(key, &root);
	}
}
```

Печать кстати происходит с помощью обхода ПКЛ, потому что сначала нужно вывести лексикографическси большие слова, потом корень, а потом лексикографически меньшие слова.

```c
void search(int x, wp* p) {  // p - указатель на указатель
	if (*p == NULL) {
		*p = (wp)malloc(sizeof)(struct word));

		(*p)->key = x;
		(*p)->count = 1;
		(*p)->l = NULL;
		(*p)->r = NULL;
	} else if (x < (*p)->key) {
		search(x, &(*p)->l);
	} else if (x > (*p)->key) {
		search(x, &(*p)->r);
	} else {
		++(*p)->count;
	}
}
```

Упражнение: Изучи что такое словарь перекрёстных ссылок.

### Исключение из деревьев
Это задача, обратная задаче включения.
Вообще, чтобы что-то сделать с деревом, нужно сделать обход (привести определение обхода). Когда мы нашли нужный элемент, нужно решить, как перестроить дерево.

Однако мы работаем с деревом поиска, поэтому исключение работает немного иначе.
Сначала элемент нужно найти (по ключу!).
Если у удаляемой вершины нет потомков, то задача решается тривиально.
Если у удаляемой вершины один потомок, то достаточно удалить вершину и перевесить этого потомка вместо него.
Если у удаляемой вершины два вершины, то задача резко усложняется.
Опираясь на свойства дерева поиска (то есть на его структуру), можно использовать следующие решения: либо заменить этот элемент самым левым элементом правого поддерева, либо заменить этот элемент самым правым элементом правого поддерева.

Упражнение: напиши все эти функции (короче сделай лабу).

Оценивая сложность дерева поиска нельзя надеяться, что оно будет сбалансированным. В худшем случае дерево вырождается в список. Однако в среднем время поиска отличается от оптимального не более чем в половину.

### Сбалансированные деревья
И всё-таки, если вершин в дереве очень и очень много, то нужно идти на ухищрения для оптимизации.

Каждая операция включения потенциально портит баланс дерева. Поэтому хочется добавить противовес - запускать операцию балансировки после вставки.
Учёными Адельсоном-Вельским и Ландисом было предложено называть сбалансированными деревьями такие деревья, у которых высоты поддеревьев каждой из вершин отличаются не более, чем на единицу. Также такие деревья называются AVL-деревьями.

В AVL-деревьях все три операции выполняются за log N, причём такие деревья нельзя изуродовать и найти тесты, которые всё испортят.

#### Включение в сбалансированное дерево
Когда структура дерева усложнилась, усложнилась и её операции - помимо поддержания структуры дерева поиска, нужно поддерживать её сбалансированность.
Схема алгоритма:
1. Поиск элемента в дереве (точнее места для вставки)
2. Включение новой вершины и определение результирующего показателя сбалансированности
3. Отходим по пути поиска (тот, по которому мы пришли в место вставки), проверяем сбалансированность для каждой проходимой вершины, балансируя в необходимых случаях соответствующие поддеревья.

#### Исключение из сбалансированного дерева
Случай с двудетной вершиной аналогичен обычному дереву поиска.
Случаи с одним ребёнком могут приводить к расбалансировке дерева, решать которую мы будем с помощью тех же инструментов, которыми пользовались при включении в дерево.

## Графы
Графом называется некоторое подмножество декартова произведения двух множеств: множеств вершин. Часто берутся не разные, а одинаковые множества. Топологически граф изображается как множество вершин (кружков, точек), соединённых линиями (называемых ребрами). Каждая пара вершин соединяется не более чем одним ребром.

Две вершины называются смежными, если у них есть общее ребро.

Говорят, что существует путь из вершины $A$ в вершину $B$, если найдётся такая последовательность вершин такая, что между двумя соседними вершинами есть ребро, первый элемент последовательности это $A$, а последний -  $B$.

Путь называется простым, если он состоит из попарно различных вершин.

Циклом называется простой путь длины не менее 3 от вершины до неё самой.

Ориентированным графом называется граф, в котором каждое ребро обладает направлением (если есть ребро $(u, v)$, то из $u$ можно попасть в $v$, но не наоборот).

Зайцев что-то сказал про алгоритм Уоршелла (...если встретился ноль, то дальше что-то там не надо...)

Как представлять графы в памяти ЭВМ? С точки зрения терминологии Кнута дерево - нелинейный вершин. Давайте рассмотрим список вершин и список дуг.  Каждой вершине сопоставим список вершин, с которыми она соединена.
### Алгоритмы на графах
#### Поиск в глубину
Поиск в графе отличается от поиска в дереве тем, что нужно постоянно следить за тем, что вершина ещё не была встречена (тут актуально привести определение обхода в глубину!).

Упражнение: Короче он максимально непонятно это всё объяснил, надо разобраться

# Сортировка и поиск
## Алгоритмы поиска
Поиск - очень частая задача. Например поиск в базе данных, поиск в интернете, антивирусное сканирование программного кода, антиспамовская фильтрация почтовых сообщений.

Для рассмотрения алгоритмов поиска предположим, что множество данных, в котором выполняется поиск, фиксировано, резидентно и допускает прямой доступ к каждому элементу (массив, короче!).

### Линейный поиск
Заключается в последовательном просмотре массива как списка. Условием завершения является:
1. Либо элемент найден $\exists i: (0\leq i \lt N) \& (a_i = x)$
2. Обход массива завершен

Ускорить поиск поможет барьерный элемент. Поместим за последним элементом ещё один элемент: равный тому, который мы ищем. Тогда из цикла можно убрать условие $i < N$.

### Двоичный поиск
Поиск данных в упорядоченном множестве с произвольным доступом к элементам более эффективен. Это связано с методом половинного деления: проверив некоторый элемент из середины, мы можем отбросить одну из половин как часть структуры, где заведомо нет искомой вершины.

Итак, основная идея двоичного поиска (пусть мы работаем с массивом, отсортированным по возрастанию):
1. Указать границы поиска как начало и конец массива 
2. Выбрать средний элемент
3. Сравнить этот элемент с искомым
	1. Если искомый элемент меньше среднего, тогда отбрасываем правую половину
	2. Иначе отбрасываем левую половину.
4. Обновляем границы поиска

### Поиск в таблице
Отличие поиска в таблице от поиска в массиве заключается в том, что в таблицах ключ обычно является составным с регулярной структурой, то есть сам является массивом, чаще всего словом или строкой.

Чтобы сравнивать строки вспомним лексикографический порядок на множестве строк
	(две формулки: 1. сравнение, 2. лексикографически меньше)

### Поиск по образцу
Другой часто встречающейся задачей является поиск вхождения подстроки в строке.


### Алгоритмы сортировки

ОГРОМНЫЙ ПРОБЕЛ!!!!!!!!!!!!


#### Сортировка выборкой

...
Сортировка вставкой по сути не сортирует, а ищет место для вставки.
Сортировка выборкой не работает на стеке (важно упомянуть на экзамене)

#### Обменные сортировки

Хотя прошлые то же содержат обмены, они немного обманывают нас: первая ищет место для вставки, вторая выбирает минимальный элемент. Этот алгоритм можно считать более честным

В этом способе сравниваются каждые два элемента, и переставляются, если они идут не по порядку.
Гидрогазодинамический смысл следующий: менее плотные объекты "всплывают" в конец массива.

> "Тут без пива никак" (с) В. Е. Зайцев

Так же, как это было в сортировке выборкой, мы можем не рассматривать уже всплывшие пузырьки.

```c
#define n 10

void BubbleSort(int a[]) {
	int x;
	for (int i = 0; i < n; ++i) {
		for (int j = n - 1; j > i; --j) {
			if (a[j - 1] > a[i]) {
				x = a[i];
				a[i] = a[j - 1];
				a[j - 1] = x;
			}
		}
	}
}
```

Можно улучшить эту сортировку следующий образом: если обменов уже не было, можно заканчивать цикл:


```c
#define n 10

void BubbleSort(int a[]) {
	int x;
	bool swapped;
	for (int i = 0; i < n; ++i) {
		swapped = false;
		for (int j = n - 1; j > i; --j) {
			if (a[j - 1] > a[i]) {
				swapped = true;
				x = a[i];
				a[i] = a[j - 1];
				a[j - 1] = x;
			}
		}
		if (!swapped) {
			break;
		}
	}
}
```

Заметим, что сортировка не симметричная: одни элементы приходят на своё место быстро, а другие - очень медленно.
Давайте тогда чередовать проходы. Сначала в одну сторону, потом в другую.

Перепиши программу, только используй слова не left и right, а up и down

Сортировка называется естественной, если она отзывчивая на изначальную упорядоченность.
Сортировка называется устойчивой, если ключи с одинаковыми значениями не переставляются.
#### Сортировка Шелла
Шелл предложил усовершенствование сортировки вставкой.
Он предложил выделять в сортируемой последовательности периодические последовательности регулярного шага, в которых происходит сортировка по отдельности.
Заметим, что этот алгоритм совершенно не подходит для сортировки стека, потому что для такой сортировки нужен прямолинейный доступ.
Начинаем мы с большого шага, который грубо отсортирует массив. Затем поменьше, который улучшит результат прошлого. Затем ещё меньше и так далее, пока шаг не станет равным единице, который окончательно отшлифует результат.

Выигрыш сортировки Шелла происходит за счёт того, что на каждом этапе либо сортируется мало элементов, либо последовательность уже хорошо отсортированная.

Задача на экзамене: составить программу сортировки Шелла

Во-первых, эта сортировка не устойчивая. Она может переставить два одинаковых ключа.
Во-вторых, у неё есть один экзотический недостаток. Виртуальная память устроена так, что редко используемые страницы тонут на диск. А сортировка постоянно дёргает эти страницы, потому что идёт большими шагами.
В-третьих, не найдена абсолютно оптимальная последовательность шагов.

#### Пирамидальная сортировка
Также эту сортировку называют турнирной. Эта сортировка ещё быстрее, чем сортировка Шелла.
Экспулатируя хорошее свойство сортировки вставкой, мы разогнали её и получили сортировку Шелла.

Давайте сделаем подобное с сортировкой выборкой. Мы находили минимальный ключ и помещали его в начало. Хотя рассматриваемая последовательность уменьшалась, мы постоянно забывали второй (третий, четвёртый...) по минимальности.
Мы не умеем на массиве - линейной структуре - расставлять какие-то флажки, пометки. А вот на дереве - вполне себе.

Идея следующая: возьмём сортируемое множество, сравним пары соседних элементов. Таких сравнений (победителей) будет n/2. Если среди победителей провести сравнения ещё раз, мы получим n/4 победителей. И так далее, всего за log n сравнений, мы получим турнирное дерево.
Однако, хранить дерево не нужно. Давайте просто хранить массив двойного размера.

Теперь, вынимая корень, нужно как-то убрать его из дерева выбора. Дерево будет постоянно перестраиваться. Идти мы будет вдоль пути побед победителя.

Сложностную оценку дать, внезапно, несложно: на каждом n нужно произвести спуск по дереву, то есть число сравнений будет равно высоте дереа: log n. 

Таким образом, эта сортировка быстрее малополиномиальной сортировки Шелла.


Главный недостаток в пространственной сложности: это двойной расход памяти.

Чтобы сократить объём расходуемой памяти, нужно приводить пирамидальное улучшение традиционных древовидных сортировок.
Пирамида (или двоичная куча) определяется как последовать элементов, удовлетворяющая условию:
$$h_i\leq h_{2i},\ h_i\leq h_{2i + 1}$$
Таким образом дерево превращается в пирамиду, на верхушке который находится минимальный элемент.
Вносимое значение всегда становится на вершину. Играя в поддавки с соседними элементами, он спускается вниз по направлению к наименьшему из соседней, пропуская на своё место наименьший элемент.
Как запрограммировать эту пирамидализацию? 
Флойд предложил лаконичное построение пирамиды в самом массиве.
Предлагается взять массив той же длины, в котором уже есть элементы.
Как будто бы уже построено турнирное дерево, но турнира не было. Перебирая тройки, мы получаем правильную структуру.

#### Гладкая сортировка
Дейкстра предложил улучшение этого алгоритма: чем более упорядоченный массив, тем быстрее сортировка, от $O(NlogN)$ вплоть до $O(N)$

Введём в рассмотрение числа Леонардо.
$L_0=L_1=1, ..., L_{k+2}=L_{k+1}+L_{k}+1$ 
Леонардова система счисления это набор чисел $p_k, ..., p_0 = \sum_{i=0}^{k}p_i L_i, \ p_i\in \{0, 1\}$.

> "Леонардовы итераторы" (с) Студент из аудитории

> "Это не просто какая-то фигня, это последовательность, известная науке"
> (с) В. Е. Зайцев

#### Быстрая сортировка
